package edu.berkeley.calnet.groovy.transform

import org.codehaus.groovy.ast.*
import org.codehaus.groovy.ast.expr.BinaryExpression
import org.codehaus.groovy.ast.expr.ConstantExpression
import org.codehaus.groovy.ast.expr.Expression
import org.codehaus.groovy.ast.expr.FieldExpression
import org.codehaus.groovy.ast.stmt.BlockStatement
import org.codehaus.groovy.ast.stmt.Statement
import org.codehaus.groovy.control.CompilePhase
import org.codehaus.groovy.control.SourceUnit
import org.codehaus.groovy.syntax.Token
import org.codehaus.groovy.syntax.Types
import org.codehaus.groovy.transform.AbstractASTTransformation
import org.codehaus.groovy.transform.CanonicalASTTransformation
import org.codehaus.groovy.transform.GroovyASTTransformation

import static org.codehaus.groovy.ast.ClassHelper.make
import static org.codehaus.groovy.ast.tools.GeneralUtils.*
import static org.codehaus.groovy.ast.tools.GenericsUtils.makeClassSafe
import static org.codehaus.groovy.ast.tools.GenericsUtils.makeClassSafeWithGenerics

/**
 * Partially derived from
 * org.codehaus.groovy.transform.EqualsAndHashCodeASTTransformation
 *
 * Used in conjunction with the @LogicalEqualsAndHashCode annotation to add
 * logicalEquals() and logicalHashCode() to an annotated class.
 */
@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
class LogicalEqualsAndHashCodeASTTransformation extends AbstractASTTransformation {
    static final Class MY_CLASS = LogicalEqualsAndHashCode.class;
    static final ClassNode MY_TYPE = make(MY_CLASS);
    static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
    private static final ClassNode OBJECT_TYPE = makeClassSafe(Object.class);
    private static final ClassNode EVAL_TYPE = makeClassSafe(Eval.class);
    private static final ClassNode STRING_TYPE = makeClassSafe(String.class);
    private static final ClassNode INTEGER_TYPE = makeClassSafe(Integer.class);
    private static final ClassNode LIST_TYPE = makeClassSafeWithGenerics(List.class, STRING_TYPE);
    private static final ClassNode METACLASS_TYPE = makeClassSafe(MetaClass.class);
    private static final ClassNode LIST_METACLASS_TYPE = makeClassSafeWithGenerics(List.class, METACLASS_TYPE)
    //private static final ClassNode DOMAINLOGICALCOMPARATOR_TYPE = make(DomainLogicalComparator.class)
    private static final ClassNode INTERFACE_TYPE = make(LogicalEqualsAndHashCodeInterface.class)
    private static final ClassNode HASHCODESALTS_TYPE = make(HashCodeSalts.class)
    private static final String EXCLUDES_FIELD = "logicalHashCodeExcludes"
    private static final String INCLUDES_FIELD = "logicalHashCodeIncludes"
    private static final String LOGICAL_HASHCODE_PROPS_FIELD = "logicalHashCodeProperties"
    private static final String HASHCODE_SALT_FIELD = "hashCodeSalt"
    private static final Token PLUS = Token.newSymbol(Types.PLUS, -1, -1)
    public static final Token XOR = Token.newSymbol(Types.BITWISE_XOR, -1, -1)
    public static final Token LEFT_PAREN = Token.newSymbol(Types.LEFT_PARENTHESIS, -1, -1)
    public static final Token RIGHT_PAREN = Token.newSymbol(Types.RIGHT_PARENTHESIS, -1, -1)
    public static final Token NULL_TOKEN = Token.newSymbol(Types.KEYWORD_NULL, -1, -1)

    public void visit(ASTNode[] nodes, SourceUnit source) {
        init(nodes, source);
        AnnotatedNode parent = (AnnotatedNode) nodes[1];
        AnnotationNode anno = (AnnotationNode) nodes[0];
        if (!MY_TYPE.equals(anno.getClassNode())) return;

        if (parent instanceof ClassNode) {
            ClassNode cNode = (ClassNode) parent;
            if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;
            List<String> excludes = getMemberList(anno, "excludes");
            List<String> includes = getMemberList(anno, "includes");
            if (hasAnnotation(cNode, CanonicalASTTransformation.MY_TYPE)) {
                AnnotationNode canonical = cNode.getAnnotations(CanonicalASTTransformation.MY_TYPE).get(0);
                if (excludes == null || excludes.isEmpty()) excludes = getMemberList(canonical, "excludes");
                if (includes == null || includes.isEmpty()) includes = getMemberList(canonical, "includes");
            }
            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;
            createIncludeExcludeFields(cNode, excludes, includes);
            FieldNode hashCodeSaltFieldNode = createHashCodeSaltField(cNode);
            createLogicalHashCodePropertiesField(cNode, excludes, includes);
            //createLogicalHashCodeField(cNode);
            //createFieldSetters(cNode, excludes, includes);
            //createSetPropertyOverride(cNode);
            createHashCode(cNode, excludes, includes, hashCodeSaltFieldNode);
            //createEquals(cNode);
            // add implements LogicalEqualsAndHashCodeInterface
            addInterface(cNode);
        }
    }

    public static void createIncludeExcludeFields(
            ClassNode cNode,
            List<String> excludes,
            List<String> includes
    ) {
        createIncludeExcludeField(cNode, EXCLUDES_FIELD, excludes)
        createIncludeExcludeField(cNode, INCLUDES_FIELD, includes)
    }

    private static void createIncludeExcludeField(ClassNode cNode, String fieldName, List<String> list) {
        boolean hasExistingField = cNode.getDeclaredField(fieldName);
        if (hasExistingField && cNode.getDeclaredField("_$fieldName")) return;

        cNode.addField(new FieldNode(
                hasExistingField ? "_$fieldName" : fieldName,
                (hasExistingField ? ACC_PRIVATE : ACC_PUBLIC) | ACC_FINAL | ACC_STATIC,
                LIST_TYPE,
                cNode,
                callX(
                        EVAL_TYPE, "me",
                        args(
                                new ConstantExpression(list.inspect() as String)
                        )
                )
        ))
    }

    private static FieldNode createHashCodeSaltField(ClassNode cNode) {
        if (cNode.getDeclaredField(HASHCODE_SALT_FIELD)) return null;

        return cNode.addField(new FieldNode(
                HASHCODE_SALT_FIELD,
                ACC_PUBLIC | ACC_FINAL | ACC_STATIC,
                INTEGER_TYPE,
                cNode,
                constX(getHashCodeSalt(cNode))
        ))
    }

    private static List<PropertyNode> getLogicalHashCodeProperties(
            ClassNode cNode,
            List<String> excludes,
            List<String> includes
    ) {
        // Need to build a list of properties in this class to include in the hash.
        // If includes is set: Property must be include list and not in optional excludes list
        // If includes is not set: Property must not be in excludes list
        return cNode.properties.findAll { PropertyNode propertyNode ->
            (!includes || includes.contains(propertyNode.name)) && !(excludes?.contains(propertyNode.name))
        }
    }

    private static FieldNode createLogicalHashCodePropertiesField(
            ClassNode cNode,
            List<String> excludes,
            List<String> includes
    ) {
        List<PropertyNode> propertyNodesToUse = getLogicalHashCodeProperties(cNode, excludes, includes)
        return cNode.addField(new FieldNode(
                LOGICAL_HASHCODE_PROPS_FIELD,
                ACC_PUBLIC | ACC_FINAL | ACC_STATIC,
                LIST_TYPE,
                cNode,
                callX(
                        EVAL_TYPE, "me",
                        args(
                                new ConstantExpression((propertyNodesToUse*.name).inspect() as String)
                        )
                )
        ))
    }

    public static FieldExpression includesExpr(ClassNode cNode) {
        return fieldX(cNode, INCLUDES_FIELD)
    }

    public static FieldExpression excludesExpr(ClassNode cNode) {
        return fieldX(cNode, EXCLUDES_FIELD)
    }

    public static void createHashCode(ClassNode cNode,
                                      List<String> excludes,
                                      List<String> includes,
                                      FieldNode hashCodeSaltFieldNode
    ) {
        if (hasDeclaredMethod(cNode, "hashCode", 0)) return;

        // method body
        final BlockStatement body = new BlockStatement();
        body.addStatement(createHashStatements(cNode, excludes, includes, hashCodeSaltFieldNode))

        // add method to class
        cNode.addMethod(new MethodNode(
                "hashCode",
                ACC_PUBLIC,
                ClassHelper.int_TYPE, // returnType
                Parameter.EMPTY_ARRAY, // parameters
                ClassNode.EMPTY_ARRAY, // exceptions
                body
        ))
    }

    // hashCode() statements
    private static Statement createHashStatements(
            ClassNode cNode,
            List<String> excludes,
            List<String> includes,
            FieldNode hashCodeSaltFieldNode
    ) {
        // HashCodeSalts.salts field
        FieldNode saltsFieldNode = HASHCODESALTS_TYPE.getDeclaredField("salts")
        assert saltsFieldNode?.isPublic() && saltsFieldNode?.isStatic()

        // Need to build a list of properties in this class to include in the hash.
        // If includes is set: Property must be include list and not in optional excludes list
        // If includes is not set: Property must not be in excludes list
        List<PropertyNode> propertyNodesToUse = getLogicalHashCodeProperties(cNode, excludes, includes)

        /**
         * Add the following code:
         * For every non-null field:
         * return salt0 ^ field0 ^ ... ^ saltN ^ fieldN
         * null fields equal a hash code of 0 with no salt.
         *
         * Returns 0 if there are no fields to include in the hash.
         */

        Expression lastExpression = constX(0)
        if (propertyNodesToUse) {
            for (int propertyIndex = 0; propertyIndex < propertyNodesToUse.size(); propertyIndex++) {
                PropertyNode propertyNode = propertyNodesToUse.get(propertyIndex);
                lastExpression = new BinaryExpression(
                        lastExpression,
                        XOR,
                        ternaryX(
                                notNullX(varX(propertyNode.name)),
                                // salt[propertyIndex] ^ propertyNode.hashCode()
                                new BinaryExpression(
                                        indexX(fieldX(HASHCODESALTS_TYPE, "salts"), constX(propertyIndex)),
                                        XOR,
                                        callX(varX(propertyNode.name), "hashCode"),
                                ),
                                constX(0)
                        )
                )
            }
        }

        return returnS(lastExpression)
    }

    public static void addInterface(ClassNode cNode) {
        cNode.addInterface(INTERFACE_TYPE)
    }

    protected static int getHashCodeSalt(ClassNode cNode) {
        return cNode.name.hashCode()
    }
}
